\subsubsection{Views}

\begin{frame}{Views}
    \begin{itemize}
        \item<1-> Views leben in \mintinline{c++}{std::ranges::views}
        \item<2-> Es gibt den alias \mintinline{c++}{std::views}
        \item<3-> Was kennzeichnet Views aus?
            \begin{itemize}
                \item<4-> lazy evaluation
                \item<5-> besitzen Inhalt nicht, referenzieren nur
                \item<6-> constant time copy and move
                \item<7-> einfach und effizient kombinierbar
            \end{itemize}
    \end{itemize}
\end{frame}

%Bemerkung: using directives

\begin{frame}{Views - Beispiel}
    \textbf{Aufgabe:}\\
    Berechne für alle Pokémon des Typs Feuer den BMI

    \vspace{2.5em}

    \begin{center}
        $\text{bmi} = \frac{\text{gewicht}}{\text{groesse}^2}$
    \end{center}
\end{frame}

\begin{frame}[fragile]{Klassisch}
    \begin{minted}[fontsize=\footnotesize]{c++}
std::vector<Pokemon> get_pokemon() {...};
auto pokemon = get_pokemon();
std::vector<int> bmis{};

for (const Pokemon& p : vec) {
    if (pokemon.type() == "Feuer") {
        int bmi = p.gewicht() / (p.groesse() ** 2);
        bmis.push_back(bmi);
    }
}
    \end{minted}
\end{frame}

% TODO old stl

\begin{frame}[fragile]{alte STL}
    \begin{minted}{c++}
std::vector<Pokemon> get_pokemon() {...};
auto pokemon = get_pokemon();
std::vector<double> bmis;

std::copy_if(
    pokemon.begin(), pokemon.end(),
    std::back_inserter(feuer_pokemon),
    hat_typ_feuer_lambda);
std::transform(
    feuer_pokemon.begin(), feuer_pokemon.end(),
    std::back_inserter(bmi),
    bmi_lambda);
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Mit Ranges}
    \begin{minted}[fontsize=\footnotesize]{c++}
std::vector<Pokemon> get_pokemon() {...};
auto pokemon = get_pokemon();
auto hat_typ_feuer = [](const Pokemon &p) {
    return p.typ == "Feuer";
};
auto bmi = [](const Pokemon &p) {
    return (p.gewicht / (p.groesse ** 2));
};

auto view = transform(filter(vec, hat_typ_feuer), bmi);

\end{minted}
\end{frame}

\begin{frame}[fragile]{Mit Ranges und Pipes}
    \begin{minted}[fontsize=\footnotesize]{c++}
std::vector<Pokemon> get_pokemon() {...};
auto pokemon = get_pokemon();
auto hat_typ_feuer = [](const Pokemon &p) {
    return p.typ == "Feuer";
};
auto bmi = [](const Pokemon &p) {
    return (p.gewicht / (p.groesse ** 2));
};

auto view = vec | filter(hat_typ_feuer) | transform(bmi);

    \end{minted}
\end{frame}

\begin{frame}[fragile]{Mit Ranges und Pipes}
    \begin{minted}[fontsize=\footnotesize]{c++}
std::vector<Pokemon> get_pokemon() {...};
auto pokemon = get_pokemon();
auto view = vec
| filter([](const Pokemon &p) {
    return p.typ == "Feuer";
})
| transform([](const Pokemon &p) {
    return (p.gewicht / (p.groesse ** 2));
});

    \end{minted}
\end{frame}

\begin{frame}[fragile]{Dangling Iterator}
    \begin{overlayarea}{\linewidth}{6cm}
        \begin{minted}[]{c++}
std::vector<Pokemon> get_pokemon() {...};

auto pokemon = get_pokemon();
auto it = min_element(
    pokemon, {},
    &Pokemon:groesse
);

std::cout << *it << std::enl;
        \end{minted}
    \end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Dangling Iterator}
    \begin{overlayarea}{\linewidth}{6cm}
        \begin{minted}[]{c++}
std::vector<Pokemon> get_pokemon() {...};

auto it = min_element(
    get_pokemon(), {},
    &Pokemon:groesse
);
std::cout << *it << std::enl;
    \end{minted}
        \begin{onlyenv}<2->
            \begin{minted}{c++}
//error: no match for ‘operator*’
//(operand type is ‘std::ranges::dangling’)
            \end{minted}
        \end{onlyenv}
    \end{overlayarea}
\end{frame}

% \begin{frame}[fragile]{Probleme}
%     \begin{minted}[]{c++}
% using std::ranges;
% std::vector<Pokemon> get_pokemons();

% auto it = find(get_pokemons(), 10, &Pokemon:groesse);
% do_something(*it);
% //error: no match for ‘operator*’
% //(operand type is ‘std::ranges::dangling’)
%     \end{minted}
% \end{frame}

\begin{frame}[fragile]{Dangling View}
    \begin{overlayarea}{\linewidth}{6cm}
        \begin{minted}{c++}
std::vector<Pokemon> get_pokemon() {...};
auto hat_typ_feuer = [](const Pokemon &p) { 
    return p.typ == "Feuer";
};

auto pokemon = get_pokemon();
auto view = views::filter(pokemon, hat_typ_feuer);
for(const Pokemon& p : view) {
    std::cout << p << std::endl;
}
    \end{minted}
        \begin{onlyenv}<-0>
            \begin{minted}{c++}
//note: candidate: ‘template<class _Range, class _Pred>
//requires (viewable_range<_Range>)
            \end{minted}
        \end{onlyenv}
    \end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Dangling View}
    \begin{overlayarea}{\linewidth}{6cm}
        \begin{minted}{c++}
std::vector<Pokemon> get_pokemon() {...};
auto hat_typ_feuer = [](const Pokemon &p) { 
    return p.typ == "Feuer";
};

auto view = views::filter(get_pokemon(), hat_typ_feuer);
for(const Pokemon& p : view) {
    std::cout << p << std::endl;
}
    \end{minted}
        \begin{onlyenv}<2->
            \begin{minted}{c++}
//note: candidate: ‘template<class _Range, class _Pred>
//requires (viewable_range<_Range>)
            \end{minted}
        \end{onlyenv}
    \end{overlayarea}
\end{frame}


\begin{frame}[fragile]{Dangling View}
    \begin{overlayarea}{\linewidth}{6cm}
        \begin{minted}{c++}
std::vector<Pokemon> get_pokemon() {...};
auto hat_typ_feuer = [](const Pokemon &p) {
    return p.typ == "Feuer";
};
auto get_feuer_pokemon(const std::vector<Pokemon>& p) {
    return p | views::filter(hat_typ_feuer);
}
    
auto view = get_feuer_pokemon(get_pokemon())
for(const Pokemon& p : view) {
    std::cout << p << std::endl;
}
        \end{minted}
        \begin{onlyenv}<2->
            \begin{minted}{c++}
//segfault
            \end{minted}
        \end{onlyenv}
    \end{overlayarea}
\end{frame}

%wann dangling view sinnvoll?

\begin{frame}[fragile]{Dangling View}
    \begin{minted}{c++}
std::string s{" Das Ist Ein Langer String. "};
auto s_view(const std::string& s) {
    [...]
    return std::string_view{s};
}
std::string_view = s_view(s);
auto view = sv
            | filter([](char c) { return c!= ' '; });
for (char c : view) {
    std::cout << c;
} //"DasIstEinLangerString"
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Dangling View}
    \begin{minted}{c++}
std::string s{" Das Ist Ein Langer String. "};
auto s_view(const std::string& s) {
    [...]
    return std::string_view{s};
}
auto view = s_view(s)
            | filter([](char c) { return c!= ' '; });
for (char c : view) {
    std::cout << c;
} //"DasIstEinLangerString"
    \end{minted}
\end{frame}

\begin{frame}{\mintinline{c++}{std::ranges::viewable_range}}
    \begin{center}
        \textbf{Was kann man einem Range adaptor alles übergeben?}
    \end{center}
\end{frame}

\begin{frame}{\mintinline{c++}{std::ranges::viewable_range}}

    \textbf{Alles was eine \mintinline{c++}{std::ranges::viewable_range} ist!}

    \begin{itemize}
        \item<2-> lvalue reference (alles mit einem Namen)
        \item<3-> \mintinline{c++}{std::borrowed_range}
            \begin{itemize}
                \item<4-> Alle views
                \item<5-> Typen mit \mintinline{c++}{std::enable_borrowed_range<T>} true
                    \begin{itemize}
                        \item<6-> \mintinline{c++}{std::span, std::string_view}
                    \end{itemize}
            \end{itemize}
    \end{itemize}
\end{frame}