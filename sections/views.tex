\subsubsection{Views}

\begin{frame}{Views}
    \begin{itemize}
        \item<1-> Lazy Evaluation
        \item<2-> einfaches Hintereinanderreihen
        \item<3-> constant time copy and move
        \item<4-> non-owning
    \end{itemize}
\end{frame}

\begin{frame}{Views - Beispiel}
    Aufgabe:

    Berechne für alle Pokémon des Typs Feuer den BMI.
\end{frame}

\begin{frame}[fragile]{Klassisch}
    \begin{minted}[fontsize=\footnotesize]{c++}
std::vector<int> bmis(const std::vector<Pokemon>& vec) {
    std::vector<int> bmis{};
    for (const Pokemon& p : vec) {
        if (pokemon.type() == "Feuer") {
            int bmi = p.gewicht() / (p.groesse() * p.groesse());
            bmis.push_back(bmi);
        }
    }
    return bmis;
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Mit Ranges}
    \begin{minted}[fontsize=\footnotesize]{c++}
auto bmis(const std::vector<Pokemon>& vec) {
    auto hat_typ_feuer = [](const Pokemon &p)
    { return p.typ == "Feuer"; };
    auto bmi = [](const Pokemon &p)
    { return (p.gewicht / (p.groesse * p.groesse)); };
    auto view = transform(filter(vec, hat_typ_feuer), bmi);
    return view;
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Mit Ranges und Pipes}
    \begin{minted}[fontsize=\footnotesize]{c++}
auto bmis(const std::vector<Pokemon>& vec) {
    auto hat_typ_feuer = [](const Pokemon &p)
    { return p.typ == "Feuer"; };
    auto bmi = [](const Pokemon &p)
    { return (p.gewicht / (p.groesse * p.groesse)); };
    auto view = vec | filter(hat_typ_feuer) | transform(bmi);
    return view;
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Mit Ranges und Pipes}
    \begin{minted}[fontsize=\footnotesize]{c++}
auto bmis(const std::vector<Pokemon>& vec) {
    auto view = vec
    | filter([](const Pokemon &p)
    { return p.typ == "Feuer"; })
    | transform([](const Pokemon &p)
    { return (p.gewicht / (p.groesse * p.groesse)); });
    return view;
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Probleme}
    \begin{overlayarea}{\linewidth}{3cm}
    \begin{minted}[]{c++}
using std::ranges;
std::vector<Pokemon> get_pokemon();

auto pokemon = get_pokemon();
auto it = min_element(
        get_pokemon(), {},
        &Pokemon:groesse
        );
do_something(*it);
    \end{minted}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]{Probleme}
    \begin{overlayarea}{\linewidth}{3cm}
    \begin{minted}[]{c++}
using std::ranges;
std::vector<Pokemon> get_pokemon();

auto it = min_element(
        get_pokemon(), {},
        &Pokemon:groesse
        );
do_something(*it);
    \end{minted}
    \begin{onlyenv}<2->
        \begin{minted}{c++}
//error: no match for ‘operator*’
//(operand type is ‘std::ranges::dangling’)
        \end{minted}
    \end{onlyenv}
\end{overlayarea}
\end{frame}

% \begin{frame}[fragile]{Probleme}
%     \begin{minted}[]{c++}
% using std::ranges;
% std::vector<Pokemon> get_pokemons();

% auto it = find(get_pokemons(), 10, &Pokemon:groesse);
% do_something(*it);
% //error: no match for ‘operator*’
% //(operand type is ‘std::ranges::dangling’)
%     \end{minted}
% \end{frame}

\begin{frame}[fragile]{Probleme 2}
    \begin{minted}{c++}
using std::ranges
std::vector<Pokemon> get_pokemon();
auto hat_typ_feuer = [](const Pokemon &p){ 
        return p.typ == "Feuer"; };

auto view = views::filter(get_pokemon(), hat_typ_feuer);
for(const Pokemon& p : view) {
    std::cout << p << std::endl;
}
//compiler error:
//note: candidate: ‘template<class _Range, class _Pred>
//requires (viewable_range<_Range>)
    \end{minted}
\end{frame}


\begin{frame}[fragile]{Probleme 2}
    \begin{minted}{c++}
using std::ranges
std::vector<Pokemon> get_pokemon();
auto hat_typ_feuer = [](const Pokemon &p)
    { return p.typ == "Feuer"; };
auto get_feuer_pokemon(const std::vector<Pokemon>& p) {
    return p | views::filter(hat_typ_feuer);
}

auto view = get_feuer_pokemon(get_pokemon())
for(const Pokemon& p : view) {
    std::cout << p << std::endl;
}
//segfault
    \end{minted}
\end{frame}